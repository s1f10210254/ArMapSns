"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[583],{8583:function(e,t,o){o.d(t,{KO:function(){return useAtom}});var r=o(7294),n=o(5103);let l=(0,r.createContext)(void 0),useStore=e=>{let t=(0,r.useContext)(l);return(null==e?void 0:e.store)||t||(0,n.K7)()},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),a=r.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;if("rejected"===e.status)throw e.reason;throw e.status="pending",e.then(t=>{e.status="fulfilled",e.value=t},t=>{e.status="rejected",e.reason=t}),e});function useAtom(e,t){return[function(e,t){let o=useStore(t),[[n,l,i],u]=(0,r.useReducer)(t=>{let r=o.get(e);return Object.is(t[0],r)&&t[1]===o&&t[2]===e?t:[r,o,e]},void 0,()=>[o.get(e),o,e]),s=n;(l!==o||i!==e)&&(u(),s=o.get(e));let m=null==t?void 0:t.delay;return(0,r.useEffect)(()=>{let t=o.sub(e,()=>{if("number"==typeof m){setTimeout(u,m);return}u()});return u(),t},[o,e,m]),(0,r.useDebugValue)(s),isPromiseLike(s)?a(s):s}(e,t),function(e,t){let o=useStore(t),n=(0,r.useCallback)((...t)=>{if(!("write"in e))throw Error("not writable atom");return o.set(e,...t)},[o,e]);return n}(e,t)]}},5103:function(e,t,o){let r;o.d(t,{K7:function(){return getDefaultStore},cn:function(){return atom}});let n=0;function atom(e,t){let o=`atom${++n}`,r={toString:()=>o};return"function"==typeof e?r.read=e:(r.init=e,r.read=e=>e(r),r.write=(e,t,o)=>t(r,"function"==typeof o?o(e(r)):o)),t&&(r.write=t),r}let hasInitialValue=e=>"init"in e,isActuallyWritableAtom=e=>!!e.write,l=new WeakMap,registerCancelPromise=(e,t)=>{l.set(e,t),e.catch(()=>{}).finally(()=>l.delete(e))},cancelPromise=(e,t)=>{let o=l.get(e);o&&(l.delete(e),o(t))},resolvePromise=(e,t)=>{e.status="fulfilled",e.value=t},rejectPromise=(e,t)=>{e.status="rejected",e.reason=t},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),isEqualAtomValue=(e,t)=>"v"in e&&"v"in t&&Object.is(e.v,t.v),isEqualAtomError=(e,t)=>"e"in e&&"e"in t&&Object.is(e.e,t.e),hasPromiseAtomValue=e=>"v"in e&&e.v instanceof Promise,isEqualPromiseAtomValue=(e,t)=>"v"in e&&"v"in t&&e.v.orig&&e.v.orig===t.v.orig,returnAtomValue=e=>{if("e"in e)throw e.e;return e.v},createStore=()=>{let e,t;let o=new WeakMap,r=new WeakMap,n=new Map;e=new Set,t=new Set;let getAtomState=e=>o.get(e),setAtomState=(e,t)=>{Object.freeze(t);let r=o.get(e);if(o.set(e,t),n.has(e)||n.set(e,r),r&&hasPromiseAtomValue(r)){let e="v"in t?t.v instanceof Promise?t.v:Promise.resolve(t.v):Promise.reject(t.e);cancelPromise(r.v,e)}},updateDependencies=(e,t,o)=>{let r=new Map,n=!1;o.forEach((o,l)=>{o||l!==e||(o=t),o?(r.set(l,o),t.d.get(l)!==o&&(n=!0)):console.warn("[Bug] atom state not found")}),(n||t.d.size!==r.size)&&(t.d=r)},setAtomValue=(e,t,o)=>{let r=getAtomState(e),n={d:(null==r?void 0:r.d)||new Map,v:t};if(o&&updateDependencies(e,n,o),r&&isEqualAtomValue(r,n)&&r.d===n.d)return r;if(r&&hasPromiseAtomValue(r)&&hasPromiseAtomValue(n)&&isEqualPromiseAtomValue(r,n)){if(r.d===n.d)return r;n.v=r.v}return setAtomState(e,n),n},setAtomValueOrPromise=(e,t,o,r)=>{if(isPromiseLike(t)){let n;let l=new Promise((r,a)=>{let i=!1;t.then(t=>{if(!i){i=!0;let n=getAtomState(e),a=setAtomValue(e,l,o);resolvePromise(l,t),r(t),(null==n?void 0:n.d)!==a.d&&mountDependencies(e,a,null==n?void 0:n.d)}},t=>{if(!i){i=!0;let r=getAtomState(e),n=setAtomValue(e,l,o);rejectPromise(l,t),a(t),(null==r?void 0:r.d)!==n.d&&mountDependencies(e,n,null==r?void 0:r.d)}}),n=e=>{i||(i=!0,e.then(e=>resolvePromise(l,e),e=>rejectPromise(l,e)),r(e))}});return l.orig=t,l.status="pending",registerCancelPromise(l,e=>{e&&n(e),null==r||r()}),setAtomValue(e,l,o)}return setAtomValue(e,t,o)},setAtomError=(e,t,o)=>{let r=getAtomState(e),n={d:(null==r?void 0:r.d)||new Map,e:t};return(o&&updateDependencies(e,n,o),r&&isEqualAtomError(r,n)&&r.d===n.d)?r:(setAtomState(e,n),n)},readAtomState=(e,t)=>{let o,n;let l=getAtomState(e);if(!t&&l&&(r.has(e)||Array.from(l.d).every(([t,o])=>t===e||readAtomState(t)===o)))return l;let a=new Map,i=!0;try{let t=e.read(t=>{if(t===e){let e=getAtomState(t);if(e)return a.set(t,e),returnAtomValue(e);if(hasInitialValue(t))return a.set(t,void 0),t.init;throw Error("no atom init")}let o=readAtomState(t);return a.set(t,o),returnAtomValue(o)},{get signal(){return o||(o=new AbortController),o.signal},get setSelf(){return isActuallyWritableAtom(e)||console.warn("setSelf function cannot be used with read-only atom"),!n&&isActuallyWritableAtom(e)&&(n=(...t)=>{if(i&&console.warn("setSelf function cannot be called in sync"),!i)return writeAtom(e,...t)}),n}});return setAtomValueOrPromise(e,t,a,()=>null==o?void 0:o.abort())}catch(t){return setAtomError(e,t,a)}finally{i=!1}},addAtom=e=>{let t=r.get(e);return t||(t=mountAtom(e)),t},canUnmountAtom=(e,t)=>!t.l.size&&(!t.t.size||1===t.t.size&&t.t.has(e)),delAtom=e=>{let t=r.get(e);t&&canUnmountAtom(e,t)&&unmountAtom(e)},recomputeDependents=e=>{let t=new Map,o=new WeakMap,loop1=e=>{let n=r.get(e);null==n||n.t.forEach(r=>{r!==e&&(t.set(r,(t.get(r)||new Set).add(e)),o.set(r,(o.get(r)||0)+1),loop1(r))})};loop1(e);let loop2=e=>{let n=r.get(e);null==n||n.t.forEach(r=>{var n;if(r!==e){let e=o.get(r);if(e&&o.set(r,--e),!e){let e=!!(null==(n=t.get(r))?void 0:n.size);if(e){let t=getAtomState(r),o=readAtomState(r,!0);e=!t||!isEqualAtomValue(t,o)}e||t.forEach(e=>e.delete(r))}loop2(r)}})};loop2(e)},writeAtomState=(t,...o)=>{let r=!0,n=t.write(e=>returnAtomValue(readAtomState(e)),(o,...n)=>{let l;if(o===t){if(!hasInitialValue(o))throw Error("atom not writable");let e=getAtomState(o),t=setAtomValueOrPromise(o,n[0]);e&&isEqualAtomValue(e,t)||recomputeDependents(o)}else l=writeAtomState(o,...n);if(!r){let t=flushPending();e.forEach(e=>e({type:"async-write",flushed:t}))}return l},...o);return r=!1,n},writeAtom=(t,...o)=>{let r=writeAtomState(t,...o),n=flushPending();return e.forEach(e=>e({type:"write",flushed:n})),r},mountAtom=(e,o)=>{var n;null==(n=getAtomState(e))||n.d.forEach((t,o)=>{let n=r.get(o);n?n.t.add(e):o!==e&&mountAtom(o,e)}),readAtomState(e);let l={t:new Set(o&&[o]),l:new Set};if(r.set(e,l),t.add(e),isActuallyWritableAtom(e)&&e.onMount){let t=e.onMount((...t)=>writeAtom(e,...t));t&&(l.u=t)}return l},unmountAtom=e=>{var o;let n=null==(o=r.get(e))?void 0:o.u;n&&n(),r.delete(e),t.delete(e);let l=getAtomState(e);l?(hasPromiseAtomValue(l)&&cancelPromise(l.v),l.d.forEach((t,o)=>{if(o!==e){let t=r.get(o);t&&(t.t.delete(e),canUnmountAtom(o,t)&&unmountAtom(o))}})):console.warn("[Bug] could not find atom state to unmount",e)},mountDependencies=(e,t,o)=>{let n=new Set(t.d.keys());null==o||o.forEach((t,o)=>{if(n.has(o)){n.delete(o);return}let l=r.get(o);l&&(l.t.delete(e),canUnmountAtom(o,l)&&unmountAtom(o))}),n.forEach(t=>{let o=r.get(t);o?o.t.add(e):r.has(e)&&mountAtom(t,e)})},flushPending=()=>{let e;for(e=new Set;n.size;){let t=Array.from(n);n.clear(),t.forEach(([t,o])=>{let n=getAtomState(t);if(n){n.d!==(null==o?void 0:o.d)&&mountDependencies(t,n,null==o?void 0:o.d);let l=r.get(t);l&&!(o&&!hasPromiseAtomValue(o)&&(isEqualAtomValue(o,n)||isEqualAtomError(o,n)))&&(l.l.forEach(e=>e()),e.add(t))}else console.warn("[Bug] no atom state to flush")})}return e};return{get:e=>returnAtomValue(readAtomState(e)),set:writeAtom,sub:(t,o)=>{let r=addAtom(t),n=flushPending(),l=r.l;return l.add(o),e.forEach(e=>e({type:"sub",flushed:n})),()=>{l.delete(o),delAtom(t),e.forEach(e=>e({type:"unsub"}))}},dev_subscribe_store:(t,o)=>{if(2!==o)throw Error("The current StoreListener revision is 2.");return e.add(t),()=>{e.delete(t)}},dev_get_mounted_atoms:()=>t.values(),dev_get_atom_state:e=>o.get(e),dev_get_mounted:e=>r.get(e),dev_restore_atoms:t=>{for(let[e,o]of t)hasInitialValue(e)&&(setAtomValueOrPromise(e,o),recomputeDependents(e));let o=flushPending();e.forEach(e=>e({type:"restore",flushed:o}))}}};"number"==typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__&&++globalThis.__NUMBER_OF_JOTAI_INSTANCES__,globalThis.__NUMBER_OF_JOTAI_INSTANCES__=1;let getDefaultStore=()=>(r||(1!==globalThis.__NUMBER_OF_JOTAI_INSTANCES__&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"),r=createStore()),r)}}]);